package com.example.phishingdetection

import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Context
import android.os.Build
import android.service.notification.NotificationListenerService
import android.service.notification.StatusBarNotification
import android.util.Log
import androidx.core.app.NotificationCompat
import org.json.JSONObject
import java.io.OutputStreamWriter
import java.net.HttpURLConnection
import java.net.URL
import java.util.concurrent.Executors
import java.util.concurrent.atomic.AtomicBoolean

class PhishingNotificationListener : NotificationListenerService() {

    private val TAG = "PhishingListener"
    private val executor = Executors.newSingleThreadExecutor()

    // Updated API URL to the ngrok public URL
    private val API_URL = "Enter Your Hosted URL/predict"

    // Flag to ensure that only one API request is sent at a time
    private val isProcessing = AtomicBoolean(false)

    override fun onNotificationPosted(sbn: StatusBarNotification) {
        if (!isSpamDetectionEnabled()) return

        // Get the package name of the notification sender
        val notificationPackageName = sbn.packageName

        // Get the package name of the app itself
        val appPackageName = packageName

        // Ignore notifications generated by this app
        if (notificationPackageName == appPackageName) {
            Log.d(TAG, "Ignoring notification from this app.")
            return
        }

        // Get notification text or skip if it's null/empty
        val notificationText = sbn.notification?.extras?.getCharSequence("android.text")?.toString()
        if (!notificationText.isNullOrEmpty() && !isProcessing.get()) {
            isProcessing.set(true) // Set processing to true to prevent re-entrance
            executor.execute {
                try {
                    val prediction = sendTextToApi(notificationText)
                    showAppNotification("Prediction Result", prediction)
                } catch (e: Exception) {
                    Log.e(TAG, "Error processing notification", e)
                } finally {
                    isProcessing.set(false)
                }
            }
        }
    }

    private fun sendTextToApi(messageText: String): String {
        return try {
            val url = URL(API_URL)
            val jsonRequest = JSONObject().apply {
                put("message", messageText) // Sending the text message for prediction
            }

            val connection = url.openConnection() as HttpURLConnection
            connection.requestMethod = "POST"
            connection.setRequestProperty("Content-Type", "application/json")
            connection.doOutput = true

            // Write JSON request to the connection output stream
            OutputStreamWriter(connection.outputStream).use { it.write(jsonRequest.toString()) }

            // Get the response from the server
            val responseCode = connection.responseCode
            val response = connection.inputStream.bufferedReader().use { it.readText() }

            // Log server response
            Log.d(TAG, "Response Code: $responseCode, Response: $response")

            if (responseCode == HttpURLConnection.HTTP_OK) {
                JSONObject(response).getString("prediction") // Assuming "prediction" contains the result
            } else {
                "Error: $responseCode - $response"
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error while sending API request", e)
            "Error: Unable to contact server."
        }
    }

    private fun showAppNotification(title: String, prediction: String) {
        val notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager

        // For Android Oreo and above, ensure a notification channel exists
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                "PhishingDetection",
                "Phishing Detection Alerts",
                NotificationManager.IMPORTANCE_HIGH
            )
            notificationManager.createNotificationChannel(channel)
        }

        val notification = NotificationCompat.Builder(this, "PhishingDetection")
            .setContentTitle(title)
            .setContentText(prediction)
            .setSmallIcon(android.R.drawable.ic_dialog_alert)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .build()

        notificationManager.notify(1, notification)
    }

    private fun isSpamDetectionEnabled(): Boolean {
        val prefs = getSharedPreferences("PhishingPrefs", Context.MODE_PRIVATE)
        return prefs.getBoolean("detection_enabled", true)
    }

    override fun onDestroy() {
        super.onDestroy()
        executor.shutdown()
    }
}
